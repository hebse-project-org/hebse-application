// --------------------------------------------------------------------
// Starts or stops an SSH tunnel to the remote database.
// When `enable` is true, it sends a POST to localhost:3001/start-tunnel
// with SSH + DB connection info from localStorage.
// When `enable` is false, it sends a POST to /stop-tunnel.
// This is used for creating a local port forward during local dev,
// when the backend is not managing the tunnel itself.
// --------------------------------------------------------------------

export const enableTunnel = async (enable: boolean) => {
    const savedSettings = localStorage.getItem("db_settings");
    if (!savedSettings) {
        return;
    }
    if (enable) {
      const decrypted = await decrypt(savedSettings);
      const parsed = JSON.parse(decrypted);
      const data = {
        databaseHost: parsed["databaseHost"],
        sshHost: parsed["sshHost"],
        sshPort: parsed["sshPort"],
        sshUser: parsed["sshUser"],
        sshKey: parsed["sshKey"]
      }
      try {
        const response = await fetch(`http://localhost:3001/start-tunnel`, {
            method: "POST",
            body: JSON.stringify(data),
            headers: {
                "Content-Type": "application/json"
            }
        });
        console.log(response);
        if (!response.ok) {
            throw new Error(`Server error: ${response.status}`);
        }
      } catch (error) {
          console.error("Error fetching query result:", error);
      }
    } else {
      try {
        const response = await fetch(`http://localhost:3001/stop-tunnel`, {
            method: "POST"
        });
        if (!response.ok) {
            throw new Error(`Server error: ${response.status}`);
        }
      } catch (error) {
          console.error("Error fetching query result:", error);
      }
    }
  }

// --------------------------------------------------------------------
// Sends a plaintext string to the backend /encrypt endpoint.
// Returns a base64-encoded ciphertext string generated by AES-GCM.
// The backend must be running and accessible at the defined API base.
// --------------------------------------------------------------------
export async function encrypt(value: string): Promise<string> {
  const r = await fetch("http://localhost:3001/encrypt", {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({ plaintext: value }),
  });
  const { ciphertext } = await r.json();
  return ciphertext;
}

// --------------------------------------------------------------------
// Sends a base64-encoded ciphertext to the backend /decrypt endpoint.
// Returns the original plaintext string decrypted using AES-GCM.
// The backend must be running and accessible at the defined API base.
// --------------------------------------------------------------------
export async function decrypt(ciphertext: string): Promise<string> {
  const r = await fetch("http://localhost:3001/decrypt", {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({ ciphertext }),
  });
  
  const body = await r.json();

  if (!r.ok) {
    if (body.clearLocalStorage) {
      localStorage.removeItem("db_list");
      localStorage.removeItem("db_settings");
      localStorage.removeItem("gpt_settings");
    }
    throw new Error(body.error || "Decrypt failed");
  }

  return body.plaintext as string;
}
